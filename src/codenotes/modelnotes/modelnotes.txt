Some notes on how the model scaling works:

The model itself is designed in "model space" coordinates
eg
        body.addBox("body", -12, 0, -16, 24, 24, 64);
this adds a box to the body with [minX, minY, minZ] at [-12, 0, -16] and a size of [24, 24, 64].
The direction of the x, y and z axes in model space are different to world space:
x points to the left of the entity, y points to its feet, and z points to its tail
for example y = 0 is higher up on the model than y = 16

When rendering, vanilla applies a scaling factor to this, which is hard-coded at 0.0625F, i.e. 1/16.
That's the "scale" variable in the call to
    public void render(EntityTameableDragon dragon, float moveTime, float moveSpeed, float ticksExisted, float lookYaw, float lookPitch, float scale)
Most vanilla models render with this scaling factor, i.e.
a box which is [16,16,16] in size corresponds to a [1,1,1] cube in minecraft, i.e. the size of a full block.

If the model needs to be rendered at a different size, this is done using GLStateManager.scale()
In vanilla, this is either done before the call to the renderer, or it's done in preRenderCallback()
DragonRenderer uses preRenderCallBack()

The origin of the model space is set up at [0, 24, 0], which means that the "feet" of your model should be at y = 24.  This will ensure that
  when you scale the model, the feet remain on the ground.  Scaling of the model uses the entity position as the origin (the entity
  posX, posY, posZ corresponds to the centre of the entity in x,z and the position of its feet in y
(This is effected by the GlStateManager.translate(0.0F, -1.501F, 0.0F); in RenderLivingBase)

Individual parts of the model can be scaled by setting the corresponding ModelPart.setRenderScale()
eg
    protected void renderHead(float scale) {
      // relativeHeadScale is updated in updateFromAnimator, depends on age of dragon
      head.setRenderScale(relativeHeadScale);   <---- this one here
      head.render(scale);
    }


At the point that the render method is called, the (x, y, z) passed to the call is the offset from the player's eye to the
entity posX, posY, posZ.  posX and posZ are the centre of the entity, and posY is the minimum.

 Each model part contains three relevant transformations, which are applied in ModelPart.postRender()
 (1) a scaling using renderScaleX, Y, Z around the origin (0,0,0)
 (2) rotation using rotateX,Y,Z around the origin of the ModelPart = 0,0,0
 (3) translation to the final rendering position using ModelPart.rotationPointX,Y,Z multiplied by the scale
     Although it's called "rotationPoint", it isn't the rotation point on the model part itself, rather it
       is a translation of the model's rotation point to a location on the parent.
     The rotation origin of the model is always 0,0,0.

     So in the case of the jaw, the jaw itself rotates around 0,0,0.  If the rotation point is (0,4,-8) then the 0,0,0
       of the jaw is translated to (0,4,-8) on the parent (the head)

    In the case of a model which is not a child (has no parents), it affect the rotation point of the entity's body pitch,
    unlike offsetX,Y,Z (see below).

 (They are in order 3,2,1 in the function but that's because of the way rendering works, i.e. the transformations are
   applied in the reverse order).

The DragonModel (eg dragon body) also has:
offsetX,Y,Z
offsetX,Y,Z is in world coordinates but is also affected by the dragon scale.  y = inverted, ie positive y makes the
   entity render lower
offsetX,Y,Z does not affect the origin used for body pitch rotation
in contrast, rotationPointX,Y,Z of the modelpart does affect it
for example
If the entity pitch is 45 degrees (rotation around X-axis):
with offsetY = 1.0 metres, the rotation point remains the top of the model (origin 0,0,0)
with rotationPointY = -8 model points, the rotation point becomes origin (0,8,0), which also has the side effect of translating the model
  upwards by 8 model points (0.5 metres) when pitch = 0.

When the two are combined, the origin of rotation can be moved without translating
eg to make the origin of rotation (0,8,0) instead of (0,0,0):
rotationPoint = -8 and offsetY = 0.5

The overall model scaling (preRenderCallback()) is always around the entity position (0,0,0) - by default this is
  the scaling of the individual model parts (renderScaleX,Y,Z) is around 0,0,0

setAngle(rotx, roty, rotz):
rotx +x = tilt forwards around y=0, z=0
roty +ve = clockwise around x=0, z = 0
rotz +ve = anticlockwise around x=0, y = 0


DEBUGGING TOOLS
DebugSettings to assist:
DebugSettings.boxDragon : render a 1x1x1 m cube instead of the dragon
DebugSettings.forceDragonModel: overwrite parameters of the dragon model

commands:
 /dragon debug parameter
 /dragon debug renderXYZmarkes: render markers at manually-entered coordinates
       use parameter to add rendered markers as defined by debug parameters (eg add marker at world [35, 5, 40]
          /dragon debug parameter wx0 35
          /dragon debug parameter wy0 5
          /dragon debug parameter wz0 40
       likewise [ex0, ey0, ez0] = add marker at location relative to origin of entity (posX, posY, posZ)
 /dragon debug setRiderPositionTweak: tweak the rider positions

 /dragon debug renderDragonPoints: show crosshairs at the major points in the dragon model

For the box dragon, use the following debug parameters:
          debugBox.rotationPointX = (float)DebugSettings.getDebugParameter("rpx");
            debugBox.rotationPointY = (float)DebugSettings.getDebugParameter("rpy");
            debugBox.rotationPointZ = (float)DebugSettings.getDebugParameter("rpz");
            debugBox.setAngles((float)DebugSettings.getDebugParameter("rax"), (float)DebugSettings.getDebugParameter("ray"),
                               (float)DebugSettings.getDebugParameter("raz"));
          debugBox.setRenderScale((float)DebugSettings.getDebugParameter("renderscale"));

For the forceDragonModel, use the following debug parameters:
            offsetX = (float)DebugSettings.getDebugParameter("ox");
            offsetY = (float)DebugSettings.getDebugParameter("oy");
            offsetZ = (float)DebugSettings.getDebugParameter("oz");
          GlStateManager.rotate(-(float)DebugSettings.getDebugParameter("pitch"), 1, 0, 0);
      scale = (float)DebugSettings.getDebugParameter("scale");

For the rider position tweaks:
      for rider 0:
            /dragon debug parameter rx0 35
            /dragon debug parameter ry0 5
            /dragon debug parameter rz0 40
      for rider 1: rx1 etc

For the tweaking of head position from body origin i.e. HEAD_OFFSET_FROM_BODY_BC:
     /dragon debug parameter headbodyx 0  (or headbodyy, headbodyz)

To force the dragon to a particular age:
   /dragon debug parameter forcedageticks number

To force dragon entity parameters:
     /dragon debug parameter dragonyaw 0
     /dragon debug parameter dragonpitch 0
      /dragon debug parameter dragonjawangle 0

To force the dragon into walking animation:
    /dragon debug forcedragonwalk
    with the cycle position set by
    /dragon debug parameter dragonwalkcycle {value}.   If {value} < 0, slowly animate

To make the dragon walk at a steady pace in a straight line:
    /dragon debug dragonWalkStraightLine
    /dragon debug parameter dragonwalkspeed 0.1

and change the animation getMoveDistancePerWalkAnimationCycleWC() using
    /dragon debug parameter walkdistancepercycle 6.0;

/kill @e[type=!Player]


------------------
